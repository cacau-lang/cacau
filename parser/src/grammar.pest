/* // TODO: make this work
impl Vec2 {
    pub fn @init x: int, y: int {
        Vec2 { x, y }
    }
}
*/


// The Cacau program
Program = _{ SOI ~ (Statement)* ~ EOI }

// -- Start of 'Expression' --

Expression = {
    Block
    | FunctionCall
    | OperatorExpression
    | IfExpression
    | Literal
    | Identifier
}

Block = { "{" ~ Statement* ~ Expression? ~ "}" }

// LEFT-RECURSIVE PROBLEM | USE ELIAS HELP
// TODO: function call is using Identifier instead of Expression, for now.
// FunctionCall = { Expression ~ "(" ~ FunctionCallArgumentList ~ ")" }
FunctionCall = { Identifier ~ "(" ~ FunctionCallArgumentList ~ ")" }
    FunctionCallArgumentList = { CommaSeparatedFunctionArgumentList }

OperatorExpression = { UnaryOperation }
// LEFT-RECURSIVE PROBLEM | USE ELIAS HELP
// OperatorExpression = { UnaryOperation | BinaryOperation }
    UnaryOperation = { UnaryOperator ~ Expression }
        UnaryOperator = { Not | Minus }
            Not = { "not" }
            Minus = { "-" }
            FlipBits = { "~" }

    // This is a simplification of `BinaryOperation` a little bit, just to get started
    // TODO: remove both `ArithmeticOperation` and `Term`
    ArithmeticOperation = { Term ~ (ArithmeticOperator ~ ArithmeticOperation) * }
    //ArithmeticOperation = { Term ~ ArithmeticPiece * }
    //ArithmeticPiece = { ArithmeticOperator ~ ArithmeticOperation }
    Term = { "(" ~ ArithmeticOperation ~ ")" | Literal | Identifier }

    BinaryOperation = { Expression ~ BinaryOperator ~ Expression }
        BinaryOperator = { ArithmeticOperator | LogicalOperator | ComparisonOperator }
            ArithmeticOperator = { Add | Subtract | Multiply | Divide | Power | Modulo }
                Add      = { "+" }
                Subtract = { "-" }
                Multiply = { "*" }
                Divide   = { "/" }
                Power    = { "^" }
                Modulo   = { "%" }
            LogicalOperator = { And | Or | BitwiseXor | BitwiseAnd | BitwiseOr | BitShiftLeft | BitShiftRight }
                And = { "and" }
                Or = { "or" }
                BitwiseXor = { "xor" } // TODO: solve this, cannot turn into `acc ^= val`
                BitwiseAnd = { "&" }
                BitwiseOr = { "|" }
                BitShiftLeft = { "<<" }
                BitShiftRight = { ">>" }
            ComparisonOperator = { Eq | Ne | Gt | Ge | Lt | Le }
                Eq = { "==" }
                Ne = { "!=" }
                Gt = { ">" }
                Ge = { ">=" }
                Lt = { "<" }
                Le = { "<=" }

IfExpression = {
    "if" ~ Expression ~ Block
    ~ ("elif" ~ Expression ~ Block)*
    ~ ("else" ~ Block)?
}

Literal = { FloatLiteral | IntegerLiteral | CharLiteral | BooleanLiteral | StringLiteral }
    // Examples: "1.1", "100.5"
    FloatLiteral = @{ IntegerLiteral ~ "." ~ IntegerLiteral }
    // Examples: "0", "100", "100_100", "1000_1000"
    IntegerLiteral = @{ Digit ~ (("_" ~ Digit) | Digit)* }
    // Examples: "a", "Ã£", "ðŸ˜Ž"
    // TODO: ANY might be dangerous, we might want to use Pest's built-ins to be more specific
    CharLiteral = @{ "'" ~ (EscapeSeq | ANY) ~ "'" }
    // A String (sequence of characters), of the form "x.." where x is any value in CharValue
    BooleanLiteral = { True | False }
        True = { "true" }
        False = { "false" }
    StringLiteral = @{ "\"" ~ (RawString | EscapeSeq)* ~ "\"" }
        RawString = @{ (!("\\" | "\"") ~ ANY)+ }

// -- End of 'expressions' --

// -- Start of 'Identifier' --

// Identifier is `UncheckedIdentifier` but checks for reserved words `keyword`
Identifier = @{ "@"? ~ &(Keyword? ~ AlphanumericOrUnderline) ~ UncheckedIdentifier }
    UncheckedIdentifier = _{ AlphaOrUnderline+ ~ AlphanumericOrUnderline* }
        Alpha = _{ 'a'..'z' | 'A'..'Z' }
        AlphaOrUnderline = _{ Alpha | "_" }
        AlphanumericOrUnderline = _{ AlphaOrUnderline | Digit }

Keyword = _{
      "if"     | "const"
    | "let"    | "enum"
    | "struct" | "pub"
    | "else"   | "not"
    | "true"   | "false"
    | "elif"   | "fn"
    | "for"
}

// Using pest built-in functionality for ignoring whitespace and comments
WHITESPACE = _{ (" " | NEWLINE) }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* } // TODO: test comments between broken expressions

Digit       = { '0'..'9' }
Arrow       = { "->" }
Hex         = _{ '0'..'9' | 'a'..'f' | 'A'..'F' }
UnicodeHex = { Hex{1, 4} }
Predefined  = { "n" | "r" | "t" | "\\" | "0" | "\"" | "'" }
Byte        = { "x" ~ Hex{2} }
Unicode     = { "u" ~ "{" ~ UnicodeHex ~ "}" }
EscapeSeq  = { "\\" ~ (Predefined | Byte | Unicode) }

// -- End of 'Identifier' --

// -- Start of 'statement' --

Statement = { LetStatement | AssignmentStatement | ExpressionStatement | Item }
    LetStatement = { "let" ~ Identifier ~ TypeAnnotation? ~ "=" ~ Expression ~ ";" }
    ExpressionStatement = { Expression ~ ";" }
    AssignmentStatement = { Identifier ~ AssignmentOperator ~ Expression ~ ";" }
        AssignmentOperator = {
            AssignOp             | ModuloAssign
            | PowerAssign        | MultiplyAssign
            | AddAssign          | DivideAssign
            | SubtractAssign     | BitwiseAndAssign
            | BitShiftLeftAssign | BitwiseOrAssign
            | BitShiftRightAssign
        }
            AssignOp              = { "=" }
            AddAssign             = { "+=" }  // (+)
            SubtractAssign        = { "-=" }  // (-)
            MultiplyAssign        = { "*=" }  // (*)
            DivideAssign          = { "/=" }  // (/)
            PowerAssign           = { "^=" }  // (^)
            ModuloAssign          = { "%=" }  // (%)
            BitwiseAndAssign     = { "&=" }  // (&)
            BitwiseOrAssign      = { "|=" }  // (|)
            BitShiftLeftAssign  = { "<<=" } // (<<)
            BitShiftRightAssign = { ">>=" } // (>>)

TypeAnnotation = { ":" ~ Identifier }

// -- End of 'statement' --

// -- Start of 'Item' --

Item = { Visibility ~ (FunctionDeclaration | StructDeclaration | ImplBlock) }
    Visibility = { "pub"? }
    ImplBlock = { "impl" ~ Identifier ~ "{" ~ FunctionDeclaration* ~ "}" }

    FunctionDeclaration = { "fn" ~ Identifier ~ FunctionParameterList ~ FunctionReturn? ~ Block }
        FunctionReturn = { Arrow ~ Identifier }
        FunctionParameterList = {
            "self"
            | (("self" ~ ",")? ~ CommaSeparatedFunctionParameterList)
        }
            FunctionParameter = { Identifier ~ TypeAnnotation }

    StructDeclaration = { UnitStruct | DetailedStruct }
        UnitStruct = { "struct" ~ Identifier ~ ";" }
        DetailedStruct = { "struct" ~ Identifier ~ "{" ~ StructFieldList ~ "}" }
            StructField = { Identifier ~ ":" ~ Identifier }
            StructFieldList = { CommaSeparatedStructFieldList }
            StructDefinition = { UnitStruct | DetailedStruct }


// -- End of 'Item' --

// -- Start of comma separated lists

CommaSeparatedFunctionParameterList = _{ (FunctionParameter ~ ("," ~ FunctionParameter)*)? ~ ","? }
CommaSeparatedFunctionArgumentList  = _{ (Expression         ~ ("," ~ Expression)*)?         ~ ","? }
CommaSeparatedStructFieldList       = _{ (StructField       ~ ("," ~ StructField)*)?       ~ ","? }

// -- End of comma separated lists
