use std::str::FromStr;

use ast::*;

grammar;

pub CacauProgram: CacauProgram = {
    Statement* => CacauProgram {
        items: <>
    }
}

Statement: Statement = {
    <expr: Expr> ";" => Statement::Expr(expr)
}

pub Expr = {
    Logic,
    VariableDecl,
    Assignment,
};

VariableDecl: Expr = {
    "let" <name: Identifier> <type_annotation:(":" <Identifier>)?> "=" <expr: Expr>
        => Expr::VarDecl(Box::new(VariableDecl{<>}))
}

Assignment: Expr = {
    <destination: Term> "=" <value: Expr>
        => Expr::Assign(Box::new(Assign{
            destination,
            operator: None,
            value
        })),
    <destination: Term> "+=" <value: Expr>
        => Expr::Assign(Box::new(Assign{
            destination,
            operator: Some(ArithOp::Add),
            value
        })),
    <destination: Term> "-=" <value: Expr>
        => Expr::Assign(Box::new(Assign{
            destination,
            operator: Some(ArithOp::Sub),
            value
        })),
    <destination: Term> "*=" <value: Expr>
        => Expr::Assign(Box::new(Assign{
            destination,
            operator: Some(ArithOp::Mul),
            value
        })),
    <destination: Term> "/=" <value: Expr>
        => Expr::Assign(Box::new(Assign{
            destination,
            operator: Some(ArithOp::Div),
            value
        })),
    <destination: Term> "%=" <value: Expr>
        => Expr::Assign(Box::new(Assign{
            destination,
            operator: Some(ArithOp::Mod),
            value
        })),
}

Logic: Expr = {
    <left: Logic> <op: LogicOp> <right: Cmp>
        => Expr::Logic(Box::new(LogicExpr{<>})),
    Cmp,
}

Cmp: Expr = {
    <left: Cmp> <op: CmpOp> <right: Sum>
        => Expr::Cmp(Box::new(CmpExpr{<>})),
    Sum,
}

Sum: Expr = {
    <left: Sum> <op: SumOp> <right: Mul>
        => Expr::Arith(Box::new(ArithExpr{<>})),
    Mul,
}

Mul: Expr = {
    <left: Mul> <op: MulOp> <right: Unary>
        => Expr::Arith(Box::new(ArithExpr{<>})),
    Unary
}

Unary: Expr = {
    "-" <expr: Unary> => Expr::Unary(Box::new(Unary::Minus(expr))),
    "not" <expr: Unary> => Expr::Unary(Box::new(Unary::Not(expr))),
    Term,
}

Term = {
    Literal,
    Identifier => Expr::Id(<>),
    "(" <expr: Expr> ")" => Expr::Paren(Box::new(expr)),
    FnCall,
}

FnCall: Expr = {
    <callee: Term> "(" <params: FnCallParams> ")"
        => Expr::FnCall(Box::new(FnCall{<>})),
}

FnCallParams: Vec<Expr> = {
    (Expr ("," <Expr>)* ","?)? => match <> {
        None => vec![],
        Some((expr, exprs, _)) => {
            let mut params = vec![expr];
            params.extend(exprs);
            params
        }
    }
}
 
CmpOp: CmpOp = {
    "==" => CmpOp::EQ,
    "!=" => CmpOp::NE,
    ">"  => CmpOp::GT,
    ">=" => CmpOp::GE,
    "<"  => CmpOp::LT,
    "<=" => CmpOp::LE,
}

LogicOp: LogicOp = {
    "or"  => LogicOp::Or,
    "and" => LogicOp::And,
    "xor" => LogicOp::Xor,
}

SumOp: ArithOp = {
    "+" => ArithOp::Add,
    "-" => ArithOp::Sub,
}

MulOp: ArithOp = {
    "*" => ArithOp::Mul,
    "/" => ArithOp::Div,
    "^" => ArithOp::Pow,
    "%" => ArithOp::Mod,
}

Literal = {
    Int,
    Float,
    Bool,
    Char,
    String,
}

match {
    r"true|false",
    r"\s*" => { }, // ignore whitespaces
    r"//[^\n\r]*[\n\r]*" => { }, // ignore comments
} else {
    _
}

Identifier: String = <s: r"[a-zA-Z_@][a-zA-Z0-9_]*">
    => s.into();

String: Expr = <s: r#""[^"]*""#>
    => Expr::Lit(Lit::String(String::from(s.trim_matches('"'))));

Char: Expr = <s: r"'[^']'">
    => Expr::Lit(Lit::Char(s.chars().skip(1).next().expect("Could not parse char")));

Float: Expr = <s: r"[0-9]+\.[0-9]">
    => Expr::Lit(Lit::Float(f64::from_str(s).expect("Could not parse float")));

Int: Expr = <s: r"[0-9]+">
    => Expr::Lit(Lit::Int(i64::from_str(s).expect("Could not parse int")));

Bool: Expr = <s: r"true|false">
    => Expr::Lit(Lit::Bool(bool::from_str(s).expect("Could not parse bool")));
